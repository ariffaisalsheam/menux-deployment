spring:
  application:
    name: menu-x-backend
  profiles:
    active: supabase

---
# Supabase Profile (PostgreSQL)
spring:
  config:
    activate:
      on-profile: supabase
  datasource:
    url: ${SUPABASE_DATABASE_URL:jdbc:postgresql://localhost:5432/menux_db}
    username: ${SUPABASE_DATABASE_USERNAME:postgres}
    password: ${SUPABASE_DATABASE_PASSWORD:password}
    driver-class-name: org.postgresql.Driver
    # HikariCP connection pool configuration for Supabase
    hikari:
      maximum-pool-size: 5
      minimum-idle: 1
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
      connection-test-query: SELECT 1
      validation-timeout: 5000
      auto-commit: true
      # PostgreSQL specific settings - disable prepared statement caching to avoid conflicts
      data-source-properties:
        cachePrepStmts: false
        prepStmtCacheSize: 0
        prepStmtCacheSqlLimit: 0
        useServerPrepStmts: false
        useLocalSessionState: true
        rewriteBatchedStatements: true
        cacheResultSetMetadata: false
        cacheServerConfiguration: true
        elideSetAutoCommits: true
        maintainTimeStats: false
        # Force simple query mode to prevent 'prepared statement already exists' error with PgBouncer
        preferQueryMode: simple
        # Additional PostgreSQL settings for Supabase
        tcpKeepAlive: true
        socketTimeout: 30
        loginTimeout: 10
  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        # Use simple query mode to avoid server-side prepares on Supabase/pgbouncer
        jdbc.prepStmtCacheSize: 0
        jdbc.prepStmtCacheSqlLimit: 0
        jdbc.use_get_generated_keys: true
        jdbc.batch_size: 50
        order_inserts: true
        order_updates: true
        connection.provider_disables_autocommit: false
        connection.autocommit: true
        connection.isolation: 2
        jdbc.time_zone: UTC
        boot.allow_jdbc_metadata_access: true
  # JSON serialization/deserialization timezone for API responses
  # Override via APP_TIME_ZONE env var (e.g., Asia/Dhaka)
  jackson:
    time-zone: ${APP_TIME_ZONE:Asia/Dhaka}
  logging:
    timezone: ${APP_TIME_ZONE:Asia/Dhaka}
  flyway:
    enabled: true
    locations: classpath:db/migration
    default-schema: public

  servlet:
    multipart:
      max-file-size: 2MB
      max-request-size: 2MB

jwt:
  secret: ${JWT_SECRET:mySecretKey123456789012345678901234567890}
  expiration: ${JWT_EXPIRATION:86400000}

app:
  time-zone: ${APP_TIME_ZONE:Asia/Dhaka}
  flyway:
    # Toggle to run Flyway repair once on startup to fix checksum mismatches (e.g., V7). Default false.
    repair-on-start: ${APP_FLYWAY_REPAIR_ON_START:false}
  frontend:
    # Frontend base URL used when generating QR code links
    # Override with APP_FRONTEND_URL env var in deployment
    url: ${APP_FRONTEND_URL:http://localhost:5173}
  media:
    supabase:
      url: ${SUPABASE_URL:https://test.supabase.co}
      service-key: ${SUPABASE_SERVICE_KEY:test-service-key}
      bucket: ${SUPABASE_STORAGE_BUCKET:menu-images}
  notifications:
    features:
      ws: ${FEATURE_WS_NOTIFS:true}
      sse: ${FEATURE_SSE_FALLBACK:true}
      fcm: ${FEATURE_FCM_PUSH:false}
    sse:
      heartbeat-ms: ${SSE_HEARTBEAT_MS:25000}
  firebase:
    admin:
      # Path to service account JSON file (mounted as secret in production)
      service-account-json: ${FIREBASE_SERVICE_ACCOUNT_JSON:}
      # Alternatively provide base64-encoded JSON via env
      service-account-json-base64: ${FIREBASE_SERVICE_ACCOUNT_JSON_BASE64:}
